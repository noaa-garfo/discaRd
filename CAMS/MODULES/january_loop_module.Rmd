---
title: "January loop for discards"
output:
  pdf_document: 
    highlight: zenburn
    toc: yes
    toc_depth: 3
    number_sections: true
  bookdown::pdf_book:
    includes:
    highlight: zenburn
    toc: yes
    toc_depth: 3
    number_sections: true
    keep_tex: yes
  html_document:
    df_print: paged
    toc: yes
editor_options: 
  chunk_output_type: console
urlcolor: cyan
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning = FALSE, 
											message = FALSE, cache = FALSE,
											progress = TRUE, verbose = FALSE, comment = F
											, error = FALSE, dev = 'png', dpi = 200)
```

```{r setup, eval = F}

t1 = Sys.time()

# setwd("C:/Users/benjamin.galuardi/Documents/GitHub/discaRd/CAMS/")

library(odbc)
library(ROracle)
library(dplyr, warn.conflicts = FALSE)
library(dbplyr)
library(ggplot2)
# library(config)
library(stringr)
library(discaRd)
options(scipen = 999)

# local run
#dw_maps <- config::get(value = "maps", file = "~/config.yml")

# # if on server..
# dw_maps <- config::get(value = "maps", file = "~/config.yml")
 
 dw_maps <- config::get(config = "maps", file = "~/config_group.yml")
# 
# bcon <- dbConnect(odbc::odbc(), 
# 									DSN = dw_maps$dsn, 
# 									UID = dw_maps$uid, 
# 									PWD = dw_maps$pwd)

# Connect to database - move this to config file in the future - quick addition for server
  connectString <- paste(
    "(DESCRIPTION=",
    "(ADDRESS=(PROTOCOL=tcp)(HOST=", dw_maps$host, ")(PORT=", dw_maps$port, "))",
    "(CONNECT_DATA=(SERVICE_NAME=",dw_maps$svc, ")))",
    sep = ""
  )

# Connect to oracle each loop in case of timeouts
    bcon <- ROracle::dbConnect(
      drv = ROracle::Oracle(),
      username = dw_maps$uid,
      password = dw_maps$pwd,
      dbname = connectString
    )


'%!in%' <- function(x,y)!('%in%'(x,y))

source('~/discaRd/CAMS/R/cams_discard_functions.R')

```

```{r define fishing year and species, eval = T}

FY <- 2019

FY_TYPE = 'JAN START'

#--------------------------------------------------------------------------#
# group of species ITIS codes.. 
# SMB, river herring, bluefish, summer flounder, 
# black seabass and scup.
#Not sure what else is needed for herring and shad catch cap.

 species_nespp3 = c('212','801','802','051', '170',
                    '023', '121', '335', '329')  # Calendar year
 
 #Need to add river herring/shad for herring only trips... maybe it is its own module?
 #AND all the SBRM species

 species = tbl(bcon, sql("select *
												from MAPS.CFG_ITIS")) %>% 
	collect() %>% 
	filter(DLR_NESPP3 %in% species_nespp3)

#--------------------------------------------------------------------------#
# a sumamry table for comaprison

final_discard_table = data.frame(YEAR = FY, SPECIES_ITIS = species$SRCE_SCI_NAME, COMNAME = species$ITIS_NAME, DISCARD = NA)

#--------------------------------------------------------------------------#

```

```{r get obs and catch data from oracle, eval = T}

# get catch and matched obs data together

c_o_dat2 <- tbl(bcon, sql(
" with obs_cams as (
   select year
	, month
	, case when month in (1,2,3,4,5,6) then 1
	       when month in (7,8,9,10,11,12) then 2
	       end as halfofyear
	-- , carea
  ,region
  , AREA
	, vtrserno
	, link1
	, docid
	, CAMSID
	, nespp3
  , itis_tsn as SPECIES_ITIS
  , itis_group1
    , SECGEAR_MAPPED as GEARCODE
	, NEGEAR
	, GEARTYPE
	, MESHGROUP
	, SECTID
, case when PERMIT = '000000' then 'STATE'
       else 'FED' end as trip_type
	, tripcategory
	, accessarea
	, activity_code_1
 --   , permit_EFP_1
 -- , permit_EFP_2
--  , permit_EFP_3
--  , permit_EFP_4
--  , redfish_exemption
--	, closed_area_exemption
--	, sne_smallmesh_exemption
--	, xlrg_gillnet_exemption
	, NVL(sum(discard),0) as discard
	, NVL(round(max(subtrip_kall)),0) as subtrip_kall
	, NVL(round(max(obs_kall)),0) as obs_kall
	, NVL(sum(discard)/round(max(obs_kall)), 0) as dk
	from MAPS.CAMS_OBS_CATCH
--	where nespp3 is not null
	group by year
  -- , carea
   ,region
  , AREA
	, vtrserno
	, link1
	, docid
	, nespp3
  , itis_tsn
  , itis_group1
    , SECGEAR_MAPPED
	, NEGEAR
	, GEARTYPE
	, MESHGROUP
	, SECTID
  , case when PERMIT = '000000' then 'STATE'
       else 'FED' end
  , CAMSID
  , month
	, halfofyear
	, tripcategory
	, accessarea
	, activity_code_1
--    , permit_EFP_1
--  , permit_EFP_2
--  , permit_EFP_3
--  , permit_EFP_4
 -- , redfish_exemption
--	, closed_area_exemption
--	, sne_smallmesh_exemption
--	, xlrg_gillnet_exemption
	order by vtrserno asc
    ) 
  select case when MONTH in (1,2,3,4) then YEAR-1 else YEAR end as GF_YEAR
  , case when MONTH in (1,2,3) then YEAR-1 else YEAR end as SCAL_YEAR
  , o.*
  , c.match_nespp3
  , coalesce(c.match_nespp3, o.nespp3) as nespp3_final
  from obs_cams o
  left join apsd.s_nespp3_match_conv c on o.nespp3 = c.nespp3        
        
"
  )
) %>%
	collect()

state_trips = c_o_dat2 %>% filter(TRIP_TYPE == 'STATE')
fed_trips = c_o_dat2 %>% filter(TRIP_TYPE == 'FED')

fed_trips = fed_trips %>% 
	mutate(ROWID = 1:nrow(fed_trips)) %>% 
	relocate(ROWID)

# filter out link1 that are doubled on VTR

multilink = fed_trips %>% 
	filter(!is.na(LINK1)) %>% 
	group_by(VTRSERNO) %>% 
	dplyr::summarise(nlink1 = n_distinct(LINK1)) %>% 
	arrange(desc(nlink1)) %>% 
	filter(nlink1>1)

remove_links = fed_trips %>% 
	filter(is.na(SPECIES_ITIS) & !is.na(LINK1) & VTRSERNO %in% multilink$VTRSERNO) %>% 
	dplyr::select(LINK1) %>% 
	distinct()

remove_id = fed_trips %>% 
    filter(is.na(SPECIES_ITIS) & !is.na(LINK1) & VTRSERNO %in% multilink$VTRSERNO) %>% 
	  distinct(ROWID)

fed_trips =
	fed_trips %>% 
	filter(ROWID %!in% remove_id$ROWID)

non_gf_dat = fed_trips%>% 
	#filter(substr(ACTIVITY_CODE_1, 1,3) != 'NMS') %>% 
	bind_rows(., state_trips)

c_o_dat2 <- fed_trips
```


```{r subset tables join and run }

# Stratification variables

stratvars = c('SPECIES_STOCK'
              ,'CAMS_GEAR_GROUP'
							, 'MESHGROUP'
							, 'HALFOFYEAR'
							, 'REGION'
						  , 'TRIPCATEGORY'
						  , 'ACCESSAREA')


# Begin loop

for(i in 1:length(species$ITIS_TSN)){

print(paste0('Running ', species$ITIS_NAME[i]))	
	
# species_nespp3 = species$NESPP3[i]  
species_itis = species$SRCE_ITIS_TSN[i] 
#--------------------------------------------------------------------------#
# Support table import by species

# GEAR TABLE
CAMS_GEAR_STRATA = tbl(bcon, sql('  select * from MAPS.CAMS_GEARCODE_STRATA')) %>% 
    collect() %>% 
  dplyr::rename(GEARCODE = VTR_GEAR_CODE) %>% 
  # filter(NESPP3 == species_nespp3) %>% 
	filter(SPECIES_ITIS == species_itis) %>%
  dplyr::select(-NESPP3, -SPECIES_ITIS)

# Stat areas table  
# unique stat areas for stock ID if needed
STOCK_AREAS = tbl(bcon, sql('select * from MAPS.CAMS_STATAREA_STOCK')) %>%
  # filter(NESPP3 == species_nespp3) %>%  # removed  & AREA_NAME == species_stock
	filter(SPECIES_ITIS == species_itis) %>%
    collect() %>% 
  group_by(AREA_NAME) %>% 
  distinct(STAT_AREA) %>%
  mutate(AREA = as.character(STAT_AREA)
         , SPECIES_STOCK = AREA_NAME) %>% 
  ungroup() #%>% 
  #dplyr::select(SPECIES_STOCK, AREA)

# Mortality table
CAMS_DISCARD_MORTALITY_STOCK = tbl(bcon, sql("select * from MAPS.CAMS_DISCARD_MORTALITY_STOCK"))  %>%
  collect() %>%
  mutate(SPECIES_STOCK = AREA_NAME
         , GEARCODE = CAMS_GEAR_GROUP) %>%
  select(-AREA_NAME) %>%
   mutate(CAMS_GEAR_GROUP = as.character(CAMS_GEAR_GROUP)) %>% 
  # filter(NESPP3 == species_nespp3) %>% 
	filter(SPECIES_ITIS == species_itis) %>%
 # dplyr::select(-NESPP3, -SPECIES_ITIS) %>% 
  dplyr::rename(DISC_MORT_RATIO = Discard_Mortality_Ratio)

#--------------------------------------------------------------------------------#
# make tables
ddat_focal <- c_o_dat2 %>% 
  filter(YEAR == FY) %>%   ## time element is here!!
  filter(AREA %in% STOCK_AREAS$AREA) %>% 
  mutate(LIVE_POUNDS = SUBTRIP_KALL
         ,SEADAYS = 0
	  		 , NESPP3 = NESPP3_FINAL) %>% 
   left_join(., y = STOCK_AREAS, by = 'AREA') %>% 
   left_join(., y = CAMS_GEAR_STRATA, by = 'GEARCODE') %>% 
   left_join(., y = CAMS_DISCARD_MORTALITY_STOCK
            , by = c('SPECIES_STOCK', 'CAMS_GEAR_GROUP')
            ) %>% 
	dplyr::select(-SPECIES_ITIS.y, -GEARCODE.y) %>% 
	dplyr::rename(SPECIES_ITIS = 'SPECIES_ITIS.x', GEARCODE = 'GEARCODE.x') %>% 
  relocate('COMMON_NAME','SPECIES_ITIS','NESPP3','SPECIES_STOCK','CAMS_GEAR_GROUP','DISC_MORT_RATIO')


ddat_prev <- c_o_dat2 %>% 
  filter(YEAR == FY-1) %>%   ## time element is here!!
  filter(AREA %in% STOCK_AREAS$AREA) %>% 
  mutate(LIVE_POUNDS = SUBTRIP_KALL
         ,SEADAYS = 0
	  		 , NESPP3 = NESPP3_FINAL) %>% 
   left_join(., y = STOCK_AREAS, by = 'AREA') %>% 
   left_join(., y = CAMS_GEAR_STRATA, by = 'GEARCODE') %>% 
   left_join(., y = CAMS_DISCARD_MORTALITY_STOCK
            , by = c('SPECIES_STOCK', 'CAMS_GEAR_GROUP')
            ) %>% 
	dplyr::select(-SPECIES_ITIS.y, -GEARCODE.y) %>% 
	dplyr::rename(SPECIES_ITIS = 'SPECIES_ITIS.x', GEARCODE = 'GEARCODE.x') %>% 
  relocate('COMMON_NAME','SPECIES_ITIS','NESPP3','SPECIES_STOCK','CAMS_GEAR_GROUP','DISC_MORT_RATIO')



# need to slice the first record for each observed trip.. these trips are multi rowed while unobs trips are single row.. 
ddat_focal_cy = ddat_focal %>% 
  filter(!is.na(LINK1)) %>% 
	mutate(SPECIES_EVAL_DISCARD = case_when(SPECIES_ITIS == species_itis ~ DISCARD
																					)) %>% 
	mutate(SPECIES_EVAL_DISCARD = coalesce(SPECIES_EVAL_DISCARD, 0)) %>% 
  group_by(LINK1, VTRSERNO) %>% 
	arrange(desc(SPECIES_EVAL_DISCARD)) %>% 
	slice(1) %>% 
  ungroup()

# and join to the unobserved trips

ddat_focal_cy = ddat_focal_cy %>% 
  union_all(ddat_focal %>% 
              filter(is.na(LINK1)) %>% 
               group_by(VTRSERNO) %>% 
               slice(1) %>% 
               ungroup()
            )


# if using the combined catch/obs table, which seems necessary for groundfish.. need to roll your own table to use with run_discard function
# DO NOT NEED TO FILTER SPECIES HERE. NEED TO RETAIN ALL TRIPS. THE MAKE_BDAT_FOCAL.R FUNCTION TAKES CARE OF THIS. 

bdat_cy = ddat_focal %>% 
  filter(!is.na(LINK1)) %>% 
  mutate(DISCARD_PRORATE = DISCARD
         , OBS_AREA = AREA
         , OBS_HAUL_KALL_TRIP = OBS_KALL
         , PRORATE = 1)


# set up trips table for previous year
ddat_prev_cy = ddat_prev %>% 
  filter(!is.na(LINK1)) %>% 
	mutate(SPECIES_EVAL_DISCARD = case_when(SPECIES_ITIS == species_itis ~ DISCARD
																					)) %>% 
	mutate(SPECIES_EVAL_DISCARD = coalesce(SPECIES_EVAL_DISCARD, 0)) %>% 
  group_by(LINK1, VTRSERNO) %>% 
	arrange(desc(SPECIES_EVAL_DISCARD)) %>% 
	slice(1) %>% 
  ungroup()

ddat_prev_cy = ddat_prev_cy %>% 
  union_all(ddat_prev %>% 
  						 filter(is.na(LINK1)) %>% 
               group_by(VTRSERNO) %>% 
               slice(1) %>% 
               ungroup()
  					)


# previous year observer data needed.. 
bdat_prev_cy = ddat_prev %>% 
  filter(!is.na(LINK1)) %>% 
  mutate(DISCARD_PRORATE = DISCARD
         , OBS_AREA = AREA
         , OBS_HAUL_KALL_TRIP = OBS_KALL
         , PRORATE = 1)

# Run the discaRd functions on previous year
d_prev = run_discard(bdat = bdat_cy
											 , ddat = ddat_prev_cy
											 , c_o_tab = ddat_prev
											 # , year = 2018
											 # , species_nespp3 = species_nespp3
										   , species_itis = species_itis
											 , stratvars = stratvars
											 , aidx = c(1,2,3) #maybe this should be bumped up?
											 )


# Run the discaRd functions on current year
d_focal = run_discard(bdat = bdat_cy
											 , ddat = ddat_focal_cy
											 , c_o_tab = ddat_focal
											 # , year = 2019
											 # , species_nespp3 = '081' # haddock...
											 # , species_nespp3 = species_nespp3  #'081' #cod...
											 , species_itis = species_itis
											 , stratvars = stratvars
											 , aidx = c(1,2,3) #maybe this should be bumped up?
											 )

# summarize each result for convenience
dest_strata_p = d_prev$allest$C %>% summarise(STRATA = STRATA
                       , N = N
                       , n = n
                       , orate = round(n/N, 2)
                       , drate = RE_mean
                       , KALL = K, disc_est = round(D)
                       , CV = round(RE_rse, 2)
										)

dest_strata_f = d_focal$allest$C %>% summarise(STRATA = STRATA
                       , N = N
                       , n = n
                       , orate = round(n/N, 2)
                       , drate = RE_mean
                       , KALL = K, disc_est = round(D)
                       , CV = round(RE_rse, 2)
										)

# substitute transition rates where needed

trans_rate_df = dest_strata_f %>% 
  left_join(., dest_strata_p, by = 'STRATA') %>% 
  	mutate(n.y = coalesce(n.y, 0)) %>% 
  mutate(STRATA = STRATA
         , n_obs_trips = n.x
         , in_season_rate = drate.x
         , previous_season_rate = drate.y
         , trans_rate = get.trans.rate(l_observed_trips = n_obs_trips
                                         , l_assumed_rate = previous_season_rate
                                         , l_inseason_rate = in_season_rate
                                         )
         ) 
  
 #Fit model for an alternative to the assumed rate
 # 
 # m_data <- d_focal$res %>% filter(!is.na(LINK1))
 # 
 # mod <- glm(OBS_DISCARD ~ offset(log(m_data$OBS_KALL+1))+
 #             SPECIES_STOCK +
 #             CAMS_GEAR_GROUP +
 #             MESHGROUP + 
 #             HALFOFYEAR + 
 #             REGION,
 #           family = poisson(),
 #           data = m_data)
 # 
 #  data_focal <- d_focal$res
 # 
 #  data_focal$OBS_KALL <- log(data_focal$OBS_KALL+1)
 # 
 # # Predict
 # data_focal <- data.frame(data_focal, D_MODEL = predict(mod, data_focal, type = "response"))   #*DISC_MORT_RATIO
 
 
 #Then join to trans_rate_df
 
 final_table = trans_rate_df %>% 
   right_join(., y = d_focal$res, by = 'STRATA') %>% 
   as_tibble() %>% 
 	 	mutate(SPECIES_ITIS_EVAL = species_itis
 				 , COMNAME_EVAL = species$COMNAME[i]
 				 , FISHING_YEAR = FY
 				 , FY_TYPE = FY_TYPE) %>%
   
   	mutate(FINAL_RATE = case_when(n_obs_trips >= 5 ~ in_season_rate  # this is an in season rate
															    ,n_obs_trips < 5 & n.y >=5 ~ trans_rate          
   	                              ,n_obs_trips < 5 & n.y < 5 ~ ARATE)
   	       ) %>%
     mutate(DISCARD_SOURCE = case_when(!is.na(LINK1) ~ 'O'
    																	, is.na(LINK1) & n_obs_trips >= 5 ~ 'I'
    																	, is.na(LINK1) & n_obs_trips < 5 & n.y>=5 ~ 'T'
    																	, is.na(LINK1) & n_obs_trips < 5 &
    																		n.y < 5 ~ 'A'))
 
 final_table = final_table %>% 
	mutate(CV = case_when(DISCARD_SOURCE == 'O' ~ 0
												, DISCARD_SOURCE == 'E' ~ CV.x
												, DISCARD_SOURCE == 'T' ~ CV.x
												, DISCARD_SOURCE == 'A' ~ CV # Im not sure this is correct?
												# , DISCARD_SOURCE == 'AT' ~ CV_f_a
												)  # , DISCARD_SOURCE == 'B' ~ NA
				 )
 
 final_table =  final_table %>% 
	mutate(coalesce(DISC_MORT_RATIO, 1)) %>%
	mutate(DISCARD = case_when(!is.na(LINK1) ~ DISC_MORT_RATIO*OBS_DISCARD
														 , is.na(LINK1) ~ DISC_MORT_RATIO*FINAL_RATE*SUBTRIP_KALL))

 species$ITIS_NAME[i]

 sum(final_table$DISCARD, na.rm=TRUE)
 sum(d_focal$res$SUBTRIP_KALL, na.rm=TRUE)

 
 #add subtrip kall after CV
 final_table <- final_table %>%
	 mutate(DATE_RUN = as.character(lubridate::today())
	 			 ,FY = as.integer(FY)) %>%
       #  ,COAL_RATE = CRATE) %>%
	dplyr::select(
	DATE_RUN,
	FY,
	SPECIES_ITIS_EVAL,
	FY_TYPE,
	ACTIVITY_CODE_1,
	VTRSERNO,
	LINK1,
	STRATA,
	STRATA_ASSUMED,
	trans_rate,
#	trans_rate_a,
#	BROAD_STOCK_RATE,
	COAL_RATE,
	DISCARD_SOURCE,
	OBS_DISCARD,
	EST_DISCARD,
	DISCARD,
	n_obs_trips,
	CV,
	eval(stratvars)
	)

 
# save trip by trip info to RDS 
 #saveRDS(final_table, file = paste0('discard_est_', species_itis, '.RDS'))
 # saveRDS(final_table, file = paste0('discard_est_', species_itis, '.RDS'))
#---------------------------------------------------------------------#
# End loop
#Need to modify this loop so it produces the oracle tables on each loop.

t2 = Sys.time()

print(paste(species_itis, ' RAN IN ', t2-t1, ' SECONDS',  sep = ''))
 
} 
 
```
```{r check that joined table has values for each trip}
 # trips that were not observed 
final_table %>%
	filter(is.na(LINK1)) %>% 
	filter(is.na(COAL_RATE))

# See if any trips do not have a discard source
final_table %>%
	filter(is.na(DISCARD_SOURCE))

# see what trips have CV and which do not

final_table %>%
	group_by(DISCARD_SOURCE) %>% 
	dplyr::summarise(mean(CV, na.rm = F))



# examine strata that have NaN for DISC_EST
dest_strata_f %>% 
	View()
```
	
	
```{r table output example}

db_example = final_table %>%
	# mutate(DATE_RUN = as.character(lubridate::today())
	# 			 , FY = as.integer(FY)) %>%
	dplyr::select(
	DATE_RUN,
	FY,
	SPECIES_ITIS_EVAL,
	FY_TYPE,
	ACTIVITY_CODE_1,
	VTRSERNO,
	LINK1,
	STRATA,
	STRATA_ASSUMED,
	trans_rate,
#	trans_rate_a,
# BROAD_STOCK_RATE,
	COAL_RATE,
	DISCARD_SOURCE,
	OBS_DISCARD,
	EST_DISCARD,
	DISCARD,
	n_obs_trips,
	CV,
	eval(stratvars)
	)

dw_apsd <- config::get(config = "apsd", file = "~/config_group.yml")
# 
# bcon <- dbConnect(odbc::odbc(), 
# 									DSN = dw_maps$dsn, 
# 									UID = dw_maps$uid, 
# 									PWD = dw_maps$pwd)

# Connect to database - move this to config file in the future - quick addition for server
  connectString <- paste(
    "(DESCRIPTION=",
    "(ADDRESS=(PROTOCOL=tcp)(HOST=", dw_apsd$host, ")(PORT=", dw_apsd$port, "))",
    "(CONNECT_DATA=(SERVICE_NAME=",dw_apsd$svc, ")))",
    sep = ""
  )

# Connect to oracle each loop in case of timeouts
    acon <- ROracle::dbConnect(
      drv = ROracle::Oracle(),
      username = dw_apsd$uid,
      password = dw_apsd$pwd,
      dbname = connectString
    )



#modify so it produces these tables in the loop.
db_drop_table(acon, 'CAMS_DISCARD_EXAMPLE_CY19')

dbWriteTable(acon, name = 'CAMS_DISCARD_EXAMPLE_CY19', value = db_example, overwrite = T)


```

