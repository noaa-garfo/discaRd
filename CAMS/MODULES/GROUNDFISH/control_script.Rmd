---
title: "Run multiple years/modules"
output:
  pdf_document: 
    highlight: zenburn
    toc: yes
    toc_depth: 3
    number_sections: true
  bookdown::pdf_book:
    includes:
    highlight: zenburn
    toc: yes
    toc_depth: 3
    number_sections: true
    keep_tex: yes
  html_document:
    df_print: paged
    toc: yes
editor_options: 
  chunk_output_type: console
urlcolor: cyan
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE
											, warning = FALSE
											, message = FALSE
											, cache = FALSE
											, progress = TRUE
											, verbose = FALSE
											, comment = F
											, error = FALSE
											, dev = 'png'
											, dpi = 200
											, prompt = F
											, results='hide')

options(dplyr.summarise.inform = FALSE)
```

```{r setup, eval = T}

# setwd("C:/Users/benjamin.galuardi/Documents/GitHub/discaRd/CAMS/")

# library(odbc)
library(ROracle)
library(dplyr, warn.conflicts = FALSE)
library(dbplyr)
library(ggplot2)
# library(config)
library(stringr)
library(discaRd)
library(fst)
options(scipen = 999)

# local run
# dw_apsd <- config::get(value = "apsd", file = "K:/R_DEV/config.yml")

# if on server..
dw_apsd <- config::get(value = "maps", file = "~/config.yml")

# bcon <- dbConnect(odbc::odbc(),
# 									DSN = dw_apsd$dsn,
# 									UID = dw_apsd$uid,
# 									PWD = dw_apsd$pwd)


bcon <- ROracle::dbConnect(
    drv = ROracle::Oracle(),
    username = dw_apsd$uid,
    password = dw_apsd$pwd,  
    dbname = "NERO.world"
)

'%!in%' <- function(x,y)!('%in%'(x,y))

source('~/PROJECTS/discaRd/CAMS/R/cams_discard_functions.R')

setwd('~/PROJECTS/discaRd/CAMS/MODULES/GROUNDFISH/')

```

```{r get obs and catch data from oracle, eval = T}

# get catch and matched obs data together

import_query = " with obs_cams as (
   select year
	, month
  , PERMIT
	, case when month in (5,6,7,8,9,10) then 1
	       when month in (11,12,1,2,3,4) then 2
	       end as halfofyear
	-- , carea
  , AREA
	, vtrserno
  , CAMS_SUBTRIP
	, link1
	, link3
	, docid
	, CAMSID
	, nespp3
  , itis_tsn as SPECIES_ITIS
  -- , itis_group1
    , SECGEAR_MAPPED as GEARCODE
	, NEGEAR
	, GEARTYPE
	, MESHGROUP
	, SECTID
  , GF
, case when activity_code_1 like 'NMS-COM%' then 'COMMON_POOL'
       when activity_code_1 like 'NMS-SEC%' then 'SECTOR'
			 else 'non_GF' end as SECTOR_TYPE
, case when PERMIT = '000000' then 'STATE'
       else 'FED' end as FED_OR_STATE
	, tripcategory
	, accessarea
	, activity_code_1
  --, permit_EFP_1
  --, permit_EFP_2
  --, permit_EFP_3
  --, permit_EFP_4
  , EM
  , redfish_exemption
	, closed_area_exemption
	, sne_smallmesh_exemption
	, xlrg_gillnet_exemption
	, NVL(sum(discard_prorate),0) as discard
	, NVL(sum(discard_prorate),0) as discard_prorate
	, NVL(round(max(subtrip_kall)),0) as subtrip_kall
	, NVL(round(max(obs_kall)),0) as obs_kall
	,  NVL(sum(discard)/nullif(round(max(obs_kall)), 0), 0) as dk
	from MAPS.CAMS_OBS_CATCH
 
 WHERE YEAR >= 2017 
  and YEAR <= 2020

	group by year
  -- , carea
  , AREA
  , PERMIT
	, vtrserno
  , CAMS_SUBTRIP
	, link1
	, link3
	, docid
	, nespp3	
  , itis_tsn
  -- , itis_group1
    , SECGEAR_MAPPED
	, NEGEAR
	, GEARTYPE
	, MESHGROUP
	, SECTID
  , GF
  , case when activity_code_1 like 'NMS-COM%' then 'COMMON_POOL'
       when activity_code_1 like 'NMS-SEC%' then 'SECTOR'
			 else 'non_GF' end
  , case when PERMIT = '000000' then 'STATE'
       else 'FED' end
  , CAMSID
  , month
	, halfofyear
	, tripcategory
	, accessarea
	, activity_code_1
  --  , permit_EFP_1
  --, permit_EFP_2
  --, permit_EFP_3
  --, permit_EFP_4
  , EM
  , redfish_exemption
	, closed_area_exemption
	, sne_smallmesh_exemption
	, xlrg_gillnet_exemption
	order by vtrserno asc
    ) 

  select case when MONTH in (1,2,3,4) then YEAR-1 else YEAR end as GF_YEAR
  , case when MONTH in (1,2,3) then YEAR-1 else YEAR end as SCAL_YEAR
  , o.*
  , c.match_nespp3
  , coalesce(c.match_nespp3, o.nespp3) as nespp3_final
  from obs_cams o
  left join apsd.s_nespp3_match_conv c on o.nespp3 = c.nespp3         
        
"

c_o_dat2 <- ROracle::dbGetQuery(bcon, import_query)
		
c_o_dat2 = c_o_dat2 %>% 
	mutate(PROGRAM = substr(ACTIVITY_CODE_1, 9, 10)) %>% 
  mutate(SCALLOP_AREA = case_when(substr(ACTIVITY_CODE_1,1,3) == 'SES' & PROGRAM == 'OP' ~ 'OPEN' 
       , PROGRAM == 'NS' ~ 'NLS'
       , PROGRAM == 'NN' ~ 'NLSN'
       , PROGRAM == 'NH' ~ 'NLSS'  # includes the NLS south Deep
       , PROGRAM == 'NW' ~ 'NLSW'
       , PROGRAM == '1S' ~ 'CAI'
       , PROGRAM == '2S' ~ 'CAII'
       , PROGRAM %in% c('MA', 'ET', 'EF', 'HC', 'DM') ~ 'MAA'
	   )
) %>% 
	mutate(SCALLOP_AREA = case_when(substr(ACTIVITY_CODE_1,1,3) == 'SES' ~ dplyr::coalesce(SCALLOP_AREA, 'OPEN'))) %>% 
	mutate(DOCID = CAMS_SUBTRIP)

# NOTE: CAMS_SUBTRIP being defined as DOCID so the discaRd functions don't have to change!! DOCID hard coded in the functions..
				 

# 4/13/22
# need to make LINK1 NA when LINK3 is null.. this is due to data mismatches in putting hauls at the subtrip level. If we don't do this step, OBS trips will get values of 0 for any evaluated species. this may or may not be correct.. it's not possible to know without a haul to subtrip match. This is a hotfix that may change in the future 

link3_na = c_o_dat2 %>% 
	filter(!is.na(LINK1) & is.na(LINK3))


# make these values 0 or NA or 'none' depending on the default for that field
link3_na = link3_na %>% 
	mutate(LINK1 = NA
				 , DISCARD = NA
				 , DISCARD_PRORATE = NA
				 , OBSRFLAG = NA
				 , OBSVTR = NA
				 , OBS_AREA = NA
				 , OBS_GEAR = NA
				 , OBS_HAUL_KALL_TRIP = 0
				 , OBS_HAUL_KEPT = 0
				 , OBS_KALL = 0
				 , OBS_LINK1 = NA
				 , OBSVTR = NA
				 , OBS_MESHGROUP = 'none'
				 , PRORATE = NA)


tidx = c_o_dat2$CAMSID %in% link3_na$CAMSID

c_o_dat2 = c_o_dat2[tidx == F,]

c_o_dat2 = c_o_dat2 %>% 
	bind_rows(link3_na)

# continue the data import


state_trips = c_o_dat2 %>% filter(FED_OR_STATE == 'STATE')
fed_trips = c_o_dat2 %>% filter(FED_OR_STATE == 'FED')

fed_trips = fed_trips %>% 
	mutate(ROWID = 1:nrow(fed_trips)) %>% 
	relocate(ROWID)

# filter out link1 that are doubled on VTR

multilink = fed_trips %>% 
	filter(!is.na(LINK1)) %>% 
	group_by(VTRSERNO) %>% 
	dplyr::summarise(nlink1 = n_distinct(LINK1)) %>% 
	arrange(desc(nlink1)) %>% 
	filter(nlink1>1)

remove_links = fed_trips %>% 
	filter(is.na(SPECIES_ITIS) & !is.na(LINK1) & VTRSERNO %in% multilink$VTRSERNO) %>% 
	dplyr::select(LINK1) %>% 
	distinct()

remove_id = fed_trips %>% 
    filter(is.na(SPECIES_ITIS) & !is.na(LINK1) & VTRSERNO %in% multilink$VTRSERNO) %>% 
	  distinct(ROWID)

fed_trips =
	fed_trips %>% 
	filter(ROWID %!in% remove_id$ROWID)

non_gf_dat = fed_trips %>% 
	filter(GF == 0) %>% 
	bind_rows(., state_trips) %>% 
	mutate(GF = "0")

gf_dat = fed_trips%>% 
	filter(GF == 1)

rm(c_o_dat2, fed_trips, state_trips)

```

```{r define fishing year and species and run RMD as a script, eval = T}

# this section may be repeated for other modules with other lists of species

#--------------------------------------------------------------------------#
# group of species
species = tbl(bcon, sql("
select distinct(b.species_itis)
    , COMNAME
    , a.nespp3
from fso.v_obSpeciesStockArea a
left join (select *  from MAPS.CAMS_GEARCODE_STRATA) b on a.nespp3 = b.nespp3
where stock_id not like 'OTHER'
and b.species_itis is not null
")
) %>% 
	collect()

# if only running yellowtail and windowpane

species = species[c(7,10),]

# make a script from RMD.. 
knitr::purl('groundfish_loop_050422.Rmd', documentation = 0)

# run two years worth of GF
for(jj in 2018:2019){
	FY <- jj
	FY_TYPE = 'MAY START'
  source('groundfish_loop_050422.R')
}

rm(list = ls())
gc()
.rs.restartR()

```

```{r combine all results for a given year, eval = T, purl = F}
#build one big table for a FY

for (FY in 2018:2019){

t1 = Sys.time()	
	
# assign('resfiles', list.files(path = '~/PROJECTS/discaRd/CAMS/MODULES/GROUNDFISH/OUTPUT/', pattern = paste0(FY,'.RDS'), full.names = T))

assign('resfiles', list.files(path = '~/PROJECTS/discaRd/CAMS/MODULES/GROUNDFISH/OUTPUT/', pattern = paste0(FY,'.fst'), full.names = T))

# cat(resfiles)			 

# res = lapply(as.list(resfiles), function(x) readRDS(x))
res = lapply(as.list(resfiles), function(x) fst::read_fst(x))

outlist <- lapply(res, function(x) { 
		x %>% 
		mutate(GF_STOCK_DEF = paste0(COMMON_NAME, '-', SPECIES_STOCK)) %>% 
		dplyr::select(-SPECIES_ITIS) %>%
		# dplyr::select(-COMMON_NAME, -SPECIES_ITIS) %>%
	dplyr::rename('STRATA_FULL' = 'FULL_STRATA'
								, 'CAMS_DISCARD_RATE' = 'COAL_RATE'
								# , 'COMMON_NAME' = 'COMNAME_EVAL'
								, 'SPECIES_ITIS' = 'SPECIES_ITIS_EVAL'
								, 'ACTIVITY_CODE' = 'ACTIVITY_CODE_1'
								, 'N_OBS_TRIPS_F' = 'n_obs_trips_f'
								) %>% 
	mutate(DATE_RUN = as.character(Sys.Date())
				 , FY = as.integer(FY)) %>%
	dplyr::select(
		DATE_RUN,
		FY,
		YEAR,
		MONTH,
		SPECIES_ITIS,
		COMMON_NAME,
		FY_TYPE,
		ACTIVITY_CODE,
		VTRSERNO,
		CAMSID,
		FED_OR_STATE,
		GF,
		AREA,
		LINK1,
		N_OBS_TRIPS_F,
		STRATA_USED,
		STRATA_FULL,
		STRATA_ASSUMED,
		DISCARD_SOURCE,
		OBS_DISCARD,
		OBS_KALL,
		SUBTRIP_KALL,
		BROAD_STOCK_RATE,
		CAMS_DISCARD_RATE,
		DISC_MORT_RATIO,
		DISCARD,
		CV,
		SPECIES_STOCK,
		CAMS_GEAR_GROUP,
		MESHGROUP,
		SECTID,
		EM,
		REDFISH_EXEMPTION,
		SNE_SMALLMESH_EXEMPTION,
		XLRG_GILLNET_EXEMPTION,
		TRIPCATEGORY,
		ACCESSAREA,
		SCALLOP_AREA
	  # eval(strata_unique)
	)
		
}
)

rm(res)

# convert list to data frame
 outlist = do.call(rbind, outlist)

# adjust for DISACRD_SOURCE = N, nan and infinite values	
	
	outlist <- outlist %>% 
 	dplyr::mutate(DISCARD_SOURCE = case_when(is.na(DISCARD) ~ 'N',TRUE ~ DISCARD_SOURCE)) %>% 
 	dplyr::mutate(STRATA_USED = case_when(is.na(DISCARD) ~ 'NA',TRUE ~ STRATA_USED))
 	
 	
 outlist$CV[is.nan(outlist$CV)]<-NA
 
 outlist$CV[is.infinite(outlist$CV)] <- NA    
 
outlist$CAMS_DISCARD_RATE[is.nan(outlist$CAMS_DISCARD_RATE)]<-NA
 
 outlist$CAMS_DISCARD_RATE[is.infinite(outlist$CAMS_DISCARD_RATE)] <- NA 
 
 outlist$BROAD_STOCK_RATE[is.nan(outlist$BROAD_STOCK_RATE)]<-NA
 
 outlist$BROAD_STOCK_RATE[is.infinite(outlist$BROAD_STOCK_RATE)] <- NA 
 
 outlist$DISCARD[is.nan(outlist$DISCARD)]<-NA
 
 outlist$DISCARD[is.infinite(outlist$DISCARD)] <- NA 

		
assign(paste0('outlist_df_',FY),  outlist)

rm(outlist)

t2 = Sys.time()

print(paste('TABLE ', paste0('outlist_df_',FY), ' BUILT IN ', round(difftime(t2, t1, units = "mins"),2), ' MINUTES',  sep = ''))

}

gc()

```

```{r check for infinite values, eval = F}

# infinite values won't upload to Oracle.. 

nans18 = lapply(outlist_df_18, function(x) sum(is.nan(x)))

infs18 = lapply(outlist_df_18, function(x) sum(is.infinite(x)))

nans19 = lapply(outlist_df_19, function(x) sum(is.nan(x)))

infs19 = lapply(outlist_df_19, function(x) sum(is.infinite(x)))


# reveals 7 CV records in 2018 that should be NA...
# reveals ~400 CV records in 2019 that should be NA...
# these are all Transition rates with no proper CV.. 

outlist_df_18$CV[is.nan(outlist_df_18$CV)] = NA
outlist_df_19$CV[is.nan(outlist_df_19$CV)] = NA

outlist_df_18$CV[is.infinite(outlist_df_18$CV)] = NA
outlist_df_19$CV[is.infinite(outlist_df_19$CV)] = NA

gc()

```


```{r upload to MAPS}
# create tables on MAPS

# try usiong this from now on.. 
# ROracle::dbWriteTable()

dw_apsd <- config::get(value = "maps", file = "~/config.yml")

bcon <- ROracle::dbConnect(
    drv = ROracle::Oracle(),
    username = dw_apsd$uid,
    password = dw_apsd$pwd,  
    dbname = "NERO.world"
)

for(i in 2018:2019){
	t1 = Sys.time()

	# db_drop_table(con = bcon, table = paste0('CAMS_DISCARD_EXAMPLE_GF',i), force = F)
	upload_table = paste0('CAMS_DISCARD_EXAMPLE_GF',i)
	
	if (ROracle::dbExistsTable(bcon, upload_table, "MAPS")){
      ROracle::dbRemoveTable(bcon, upload_table)
	}
	
	    ROracle::dbWriteTable(conn = bcon, name = upload_table, value =  get(paste0('outlist_df_', i)) , row.names = FALSE, overwrite = FALSE)
	

	# dbWriteTable(bcon, name = paste0('CAMS_DISCARD_EXAMPLE_GF',i), value =  get(paste0('outlist_df_', i)), overwrite = T)
	
	t2 =  Sys.time()
	print(paste0('Year ', i, ' took ', round(difftime(t2, t1, units = "mins"),2), ' minutes to save'))
	
	# create indices 
	idx1 = paste0("CREATE INDEX yearidx_gf", i, " ON ", paste0('CAMS_DISCARD_EXAMPLE_GF', i) ,"(YEAR, MONTH)")
	idx2 = paste0("CREATE INDEX itisidx_gf", i, " ON ", paste0('CAMS_DISCARD_EXAMPLE_GF', i) ,"(SPECIES_ITIS)")
	ROracle::dbSendQuery(bcon, idx1)
	ROracle::dbSendQuery(bcon, idx2)

}
```


```{r grant all discard tables from MAPS to CAMS_GARFO}

tab_list = ROracle::dbGetQuery(bcon, " 
SELECT object_name, object_type
    FROM all_objects
    WHERE object_type = 'TABLE'
    and owner = 'MAPS'
and object_name like 'CAMS_DISCARD%'
and object_name not like '%DISCARD_MORTALITY%'
															 ")

  sq = paste0("GRANT SELECT ON MAPS.", tab_list$OBJECT_NAME," TO CAMS_GARFO")
	
  # sq = stringr::str_flatten(sq)
  
  for(i in 1:nrow(tab_list)){
  	ROracle::dbSendQuery(bcon, sq[i])
  }
```

```{r  create tables on cams_garfo}
 # now make the tables on CAMS_GARFO

condat <- config::get(value = "bgaluardi_cams_garfo", file = "~/config.yml")

ccon = ROracle::dbConnect(
    drv = ROracle::Oracle(),
    username = condat$uid,
    password = condat$pwd,  
    dbname = "NERO.world"
)


tab_list_cm = ROracle::dbGetQuery(ccon, " 
SELECT object_name, object_type
    FROM all_objects
    WHERE object_type = 'TABLE'
    and owner = 'CAMS_GARFO'
and object_name like 'CAMS_DISCARD%'
and object_name not like '%DISCARD_MORTALITY%'
															 "
)

# remove all the old tables
 for(i in 1:nrow(tab_list_cm)){
    	if(ROracle::dbExistsTable(ccon, tab_list_cm$OBJECT_NAME[i])){
    		ROracle::dbRemoveTable(ccon, tab_list_cm$OBJECT_NAME[i])
    	}
 }


# make a list of tables to  add
  make_tab_sq = paste0("CREATE TABLE CAMS_GARFO.", tab_list$OBJECT_NAME," AS SELECT * FROM MAPS.", tab_list$OBJECT_NAME)
  
# make the tables from MAPS
  for(i in 1:nrow(tab_list)){
  	print(paste0("MAKING TABLE ",  make_tab_sq[i], " ON CAMS_GARFO"))
  	ROracle::dbSendQuery(ccon, make_tab_sq[i])
  }

```


```{r make a view for all discards on CAMS_GARFO}
# get list of discard tables on CAMS_GARFO

tab_list = ROracle::dbGetQuery(ccon, " 
SELECT object_name, object_type
    FROM all_objects
    WHERE object_type = 'TABLE'
    and owner = 'CAMS_GARFO'
and object_name like 'CAMS_DISCARD%'
and object_name not like '%DISCARD_MORTALITY%'
															 ")

st = "CREATE OR REPLACE VIEW CAMS_GARFO.CAMS_DISCARD_ALL_YEARS AS "

tab_line = paste0("select * from CAMS_GARFO.", tab_list$OBJECT_NAME," UNION ALL " )  # [22:23]  # groundfish only.. 

# bidx = grep('*MORTALITY*', tab_line)
# 
# tab_line = tab_line[-bidx]

tab_line[length(tab_line)] = gsub(replacement = "", pattern = "UNION ALL", x = tab_line[length(tab_line)])


# create a script to pass to SQL

sq = stringr::str_c(st, stringr::str_flatten(tab_line))

# pass the script to make a view
ROracle::dbSendQuery(ccon, sq)


# Grant to CAMS_GARFO

# ROracle::dbSendQuery(bcon, "GRANT SELECT ON MAPS.CAMS_DISCARD_ALL_YEARS TO CAMS_GARFO")

# Grant to CAMS_GARFO_FOR_NEFSC

ROracle::dbSendQuery(ccon, "GRANT SELECT ON CAMS_GARFO.CAMS_DISCARD_ALL_YEARS TO CAMS_GARFO_FOR_NEFSC")

# test it!


ROracle::dbGetQuery(ccon, "
	select round(sum(discard)) as total_discard
	, species_stock
	, COMMON_NAME
	, species_itis
	, FY
	, GF
	from CAMS_GARFO.CAMS_DISCARD_ALL_YEARS
	group by species_itis, fy, species_stock, GF, COMMON_NAME
	order by COMMON_NAME
	"
)


```

